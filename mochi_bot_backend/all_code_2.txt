

# File: concat.py

import os

def load_gitignore(gitignore_path):
    ignored_paths = set()
    if os.path.isfile(gitignore_path):
        with open(gitignore_path, 'r') as gitignore:
            for line in gitignore:
                line = line.strip()
                if line and not line.startswith('#'):
                    ignored_paths.add(line)
    return ignored_paths

def is_ignored(path, ignored_paths):
    for pattern in ignored_paths:
        if pattern.startswith('/'):
            pattern = pattern[1:]
        if pattern.endswith('/'):
            pattern = pattern[:-1]
        if pattern in path:
            return True
    return False

def concatenate_codebase_with_comments(src_directory, output_file, extensions, gitignore_path):
    ignored_paths = load_gitignore(gitignore_path)
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for subdir, _, files in os.walk(src_directory):
            for file in files:
                file_path = os.path.relpath(os.path.join(subdir, file), src_directory)
                if any(file.endswith(ext) for ext in extensions) and not is_ignored(file_path, ignored_paths):
                    full_file_path = os.path.join(src_directory, file_path)
                    with open(full_file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(f"\n\n# File: {file_path}\n\n")
                        outfile.write(infile.read())

src_directory = '/Users/aviz/mochi_bot/mochi_bot_backend'  # Replace with your codebase directory
output_file = 'all_code.txt'  # Replace with your desired output file path
extensions = ['.py', '.js', '.html', '.css']  # Add more extensions if needed

concatenate_codebase_with_comments(src_directory, output_file, extensions, '.gitignore')

# File: manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mochi_bot_backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


# File: generate_secret_key.py

from django.core.management.utils import get_random_secret_key
print(get_random_secret_key())

# File: chatbot/file_handler.py

import os
from werkzeug.utils import secure_filename
from django.conf import settings
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

ALLOWED_EXTENSIONS = {'txt', 'pdf', 'docx'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def save_uploaded_file(file):
    if file and allowed_file(file.name):
        filename = secure_filename(file.name)
        path = default_storage.save(f'uploads/{filename}', ContentFile(file.read()))
        return path
    return None

def delete_file(file_path):
    if default_storage.exists(file_path):
        default_storage.delete(file_path)
        return True
    return False

def get_file_url(file_path):
    return default_storage.url(file_path)

# File: chatbot/models.py

from django.db import models
from django.contrib.auth.models import AbstractUser
import uuid
from enum import Enum

class UserRole(models.TextChoices):
    ADMIN = 'admin', 'Admin'
    MANAGER = 'manager', 'Manager'
    USER = 'user', 'User'

class User(AbstractUser):
    display_name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    role = models.CharField(max_length=10, choices=UserRole.choices, default=UserRole.USER)

    groups = models.ManyToManyField(
        'auth.Group',
        related_name='custom_user_set',  # Change this to avoid conflict
        blank=True,
        help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.',
        verbose_name='groups',
    )
    user_permissions = models.ManyToManyField(
        'auth.Permission',
        related_name='custom_user_set',  # Change this to avoid conflict
        blank=True,
        help_text='Specific permissions for this user.',
        verbose_name='user permissions',
    )

    def to_dict(self):
        return {
            'id': str(self.id),
            'username': self.username,
            'display_name': self.display_name,
            'email': self.email,
            'role': self.role,
        }

class Chatbot(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    desc = models.TextField(blank=True)
    owner = models.ForeignKey(User, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    chatbot_type = models.CharField(max_length=50)
    settings = models.JSONField(default=dict)
    visible = models.BooleanField(default=True)
    guest_allowed = models.BooleanField(default=True)

    def to_dict(self):
        return {
            'id': str(self.id),
            'name': self.name,
            'desc': self.desc,
            'owner_id': str(self.owner.id),
            'created_at': self.created_at.isoformat(),
            'chatbot_type': self.chatbot_type,
            'settings': self.settings,
            'visible': self.visible,
            'guest_allowed': self.guest_allowed,
        }

class Thread(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    chatbot = models.ForeignKey(Chatbot, on_delete=models.CASCADE)
    owner = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict)
    visible = models.BooleanField(default=True)

    def to_dict(self):
        return {
            'id': str(self.id),
            'chatbot_id': str(self.chatbot.id),
            'owner_id': str(self.owner.id) if self.owner else None,
            'created_at': self.created_at.isoformat(),
            'metadata': self.metadata,
            'visible': self.visible,
        }

class Message(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    thread = models.ForeignKey(Thread, on_delete=models.CASCADE)
    role = models.CharField(max_length=50)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict)
    visible = models.BooleanField(default=True)

    def to_dict(self):
        return {
            'id': str(self.id),
            'thread_id': str(self.thread.id),
            'role': self.role,
            'content': self.content,
            'created_at': self.created_at.isoformat(),
            'metadata': self.metadata,
            'visible': self.visible,
        }

# File: chatbot/serializers.py

# serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User
from django.contrib.auth import authenticate

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email')

class LoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField()

    def validate(self, data):
        username = data.get('username')
        password = data.get('password')

        if username and password:
            user = authenticate(username=username, password=password)
            if user:
                data['user'] = user
            else:
                raise serializers.ValidationError("Unable to log in with provided credentials.")
        else:
            raise serializers.ValidationError("Must include 'username' and 'password'.")
        return data

# File: chatbot/__init__.py



# File: chatbot/apps.py

from django.apps import AppConfig


class ChatbotConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chatbot'


# File: chatbot/factory.py

import os
import json
from importlib import import_module

class ChatbotFactory:
    _chatbot_types = {}

    @classmethod
    def register_chatbot_types(cls):
        chatbot_types_dir = os.path.join(os.path.dirname(__file__), 'chatbot_types')
        for type_folder in os.listdir(chatbot_types_dir):
            type_path = os.path.join(chatbot_types_dir, type_folder)
            if os.path.isdir(type_path):
                metadata_path = os.path.join(type_path, 'metadata.json')
                if os.path.exists(metadata_path):
                    with open(metadata_path, 'r') as f:
                        metadata = json.load(f)
                    chatbot_module = import_module(f'.chatbot_types.{type_folder}.chatbot', package='chatbot')
                    chatbot_class = getattr(chatbot_module, f"{metadata['name']}Chatbot")
                    cls._chatbot_types[metadata['type']] = {
                        'class': chatbot_class,
                        'metadata': metadata
                    }

    @classmethod
    def create_chatbot(cls, chatbot_data):
        if not cls._chatbot_types:
            cls.register_chatbot_types()
        
        chatbot_type = chatbot_data['chatbot_type']
        if chatbot_type not in cls._chatbot_types:
            raise ValueError(f"Unknown chatbot type: {chatbot_type}")
        
        return cls._chatbot_types[chatbot_type]['class'](chatbot_data)

    @classmethod
    def get_chatbot_metadata(cls, chatbot_type):
        if not cls._chatbot_types:
            cls.register_chatbot_types()
        
        if chatbot_type not in cls._chatbot_types:
            raise ValueError(f"Unknown chatbot type: {chatbot_type}")
        
        return cls._chatbot_types[chatbot_type]['metadata']

    @classmethod
    def get_all_chatbot_types(cls):
        if not cls._chatbot_types:
            cls.register_chatbot_types()
        
        return [
            {'type': chatbot_type, 'name': info['metadata']['name'], 'description': info['metadata']['description']}
            for chatbot_type, info in cls._chatbot_types.items()
        ]

# File: chatbot/admin.py

from django.contrib import admin

# Register your models here.


# File: chatbot/storage.py

import json
import os
from typing import Dict, Any

class JSONFileStorage:
    def __init__(self, file_path: str):
        self.file_path = file_path
        self.ensure_file_exists()

    def ensure_file_exists(self):
        if not os.path.exists(self.file_path):
            with open(self.file_path, 'w') as f:
                json.dump({}, f)

    def read(self) -> Dict[str, Any]:
        with open(self.file_path, 'r') as f:
            return json.load(f)

    def write(self, data: Dict[str, Any]):
        with open(self.file_path, 'w') as f:
            json.dump(data, f, indent=2)

    def get(self, key: str) -> Any:
        data = self.read()
        return data.get(key)

    def set(self, key: str, value: Any):
        data = self.read()
        data[key] = value
        self.write(data)

    def delete(self, key: str):
        data = self.read()
        if key in data:
            del data[key]
            self.write(data)

    def list_keys(self) -> list:
        return list(self.read().keys())

# File: chatbot/tests.py

from django.test import TestCase

# Create your tests here.


# File: chatbot/views.py

from django.shortcuts import render
from django.http import JsonResponse
from django.contrib.auth import authenticate
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.tokens import RefreshToken
import json
from .storage import JSONFileStorage
from .models import User, Chatbot, Thread, Message, UserRole
from .factory import ChatbotFactory
from .file_handler import save_uploaded_file, delete_file, get_file_url
from .serializers import UserSerializer, LoginSerializer

storage = JSONFileStorage('db.json')

@api_view(['POST'])
@permission_classes([AllowAny])
def register_user(request):
    data = json.loads(request.body)
    username = data.get('username')
    email = data.get('email')
    password = data.get('password')
    display_name = data.get('display_name', username)
    role = UserRole.USER

    if User.objects.filter(username=username).exists():
        return JsonResponse({'error': 'Username already exists'}, status=400)

    user = User.objects.create_user(username=username, email=email, password=password, display_name=display_name, role=role)
    user.save()

    return JsonResponse(UserSerializer(user).data, status=201)

@api_view(['POST'])
@permission_classes([AllowAny])
def login_user(request):
    serializer = LoginSerializer(data=request.data)
    if serializer.is_valid():
        user = serializer.validated_data['user']
        refresh = RefreshToken.for_user(user)
        return JsonResponse({
            'refresh': str(refresh),
            'access': str(refresh.access_token),
            'user': UserSerializer(user).data
        })
    return JsonResponse(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout_user(request):
    request.auth.delete()
    return JsonResponse({}, status=200)

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def chatbot_list(request):
    if request.method == 'GET':
        chatbots = Chatbot.objects.all()
        return JsonResponse([chatbot.to_dict() for chatbot in chatbots], safe=False)
    elif request.method == 'POST':
        data = json.loads(request.body)
        chatbot_type = data['chatbot_type']
        
        try:
            metadata = ChatbotFactory.get_chatbot_metadata(chatbot_type)
        except ValueError as e:
            return JsonResponse({'error': str(e)}, status=400)
        
        chatbot = Chatbot(
            name=data['name'],
            desc=data.get('desc', ''),
            owner=request.user,
            chatbot_type=chatbot_type
        )
        chatbot.settings = {k: v['default'] for k, v in metadata['settings_schema'].items()}
        chatbot.save()

        return JsonResponse(chatbot.to_dict(), status=201)

@api_view(['GET', 'PUT', 'DELETE'])
@permission_classes([IsAuthenticated])
def chatbot_detail(request, chatbot_id):
    try:
        chatbot = Chatbot.objects.get(id=chatbot_id)
    except Chatbot.DoesNotExist:
        return JsonResponse({'error': 'Chatbot not found'}, status=404)

    if request.method == 'GET':
        return JsonResponse(chatbot.to_dict())
    elif request.method == 'PUT':
        data = json.loads(request.body)
        chatbot.name = data.get('name', chatbot.name)
        chatbot.desc = data.get('desc', chatbot.desc)
        chatbot.settings = data.get('settings', chatbot.settings)
        chatbot.save()
        return JsonResponse(chatbot.to_dict())
    elif request.method == 'DELETE':
        chatbot.delete()
        return JsonResponse({}, status=204)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_thread(request):
    data = json.loads(request.body)
    thread = Thread(
        chatbot_id=data['chatbot_id'],
        owner_id=request.user.id
    )
    thread.save()
    return JsonResponse(thread.to_dict(), status=201)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def send_message(request, chatbot_id, thread_id):
    data = json.loads(request.body)
    content = data['content']

    try:
        chatbot = Chatbot.objects.get(id=chatbot_id)
        thread = Thread.objects.get(id=thread_id)
    except (Chatbot.DoesNotExist, Thread.DoesNotExist):
        return JsonResponse({'error': 'Invalid chatbot or thread'}, status=404)

    user_message = Message(thread=thread, role='user', content=content)
    user_message.save()
    
    response = chatbot.generate_response(content, thread_id)
    
    assistant_message = Message(thread=thread, role='assistant', content=response)
    assistant_message.save()

    return JsonResponse({
        'user_message': user_message.to_dict(),
        'assistant_message': assistant_message.to_dict()
    }, status=200)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_chatbot_types(request):
    chatbot_types = ChatbotFactory.get_all_chatbot_types()
    return JsonResponse(chatbot_types, safe=False)

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def upload_document(request, chatbot_id):
    try:
        chatbot = Chatbot.objects.get(id=chatbot_id)
    except Chatbot.DoesNotExist:
        return JsonResponse({'error': 'Chatbot not found'}, status=404)

    if 'file' not in request.FILES:
        return JsonResponse({'error': 'No file part'}, status=400)
    
    file = request.FILES['file']
    file_path = save_uploaded_file(file)
    
    if file_path:
        if 'documents' not in chatbot.settings:
            chatbot.settings['documents'] = []
        chatbot.settings['documents'].append({
            'name': file.name,
            'path': file_path
        })
        chatbot.save()
        return JsonResponse({'message': 'File uploaded successfully', 'file_path': file_path})
    else:
        return JsonResponse({'error': 'File upload failed'}, status=400)

@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_document(request, chatbot_id, document_name):
    try:
        chatbot = Chatbot.objects.get(id=chatbot_id)
    except Chatbot.DoesNotExist:
        return JsonResponse({'error': 'Chatbot not found'}, status=404)
    documents = chatbot.settings.get('documents', [])
    document = next((doc for doc in documents if doc['name'] == document_name), None)

    if document:
        if delete_file(document['path']):
            documents.remove(document)
            chatbot.settings['documents'] = documents
            chatbot.save()
            return JsonResponse({'message': 'Document deleted successfully'})
        else:
            return JsonResponse({'error': 'Failed to delete document'}, status=500)
    else:
        return JsonResponse({'error': 'Document not found'}, status=404)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_documents(request, chatbot_id):
    try:
        chatbot = Chatbot.objects.get(id=chatbot_id)
    except Chatbot.DoesNotExist:
        return JsonResponse({'error': 'Chatbot not found'}, status=404)
    documents = chatbot.settings.get('documents', [])

    for doc in documents:
        doc['url'] = get_file_url(doc['path'])

    return JsonResponse({'documents': documents})

# File: chatbot/migrations/__init__.py



# File: chatbot/migrations/0001_initial.py

# Generated by Django 4.2.14 on 2024-07-13 18:37

import django.contrib.auth.models
import django.contrib.auth.validators
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='Chatbot',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('desc', models.TextField(blank=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('chatbot_type', models.CharField(max_length=50)),
                ('settings', models.JSONField(default=dict)),
                ('visible', models.BooleanField(default=True)),
                ('guest_allowed', models.BooleanField(default=True)),
            ],
        ),
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('display_name', models.CharField(max_length=100)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('role', models.CharField(choices=[('admin', 'Admin'), ('manager', 'Manager'), ('user', 'User')], default='user', max_length=10)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='custom_user_set', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='custom_user_set', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'user',
                'verbose_name_plural': 'users',
                'abstract': False,
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
        migrations.CreateModel(
            name='Thread',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('metadata', models.JSONField(default=dict)),
                ('visible', models.BooleanField(default=True)),
                ('chatbot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='chatbot.chatbot')),
                ('owner', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, to='chatbot.user')),
            ],
        ),
        migrations.CreateModel(
            name='Message',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(max_length=50)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('metadata', models.JSONField(default=dict)),
                ('visible', models.BooleanField(default=True)),
                ('thread', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='chatbot.thread')),
            ],
        ),
        migrations.AddField(
            model_name='chatbot',
            name='owner',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='chatbot.user'),
        ),
    ]


# File: chatbot/managment/commands/createsuperuser.py

from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
import os

class Command(BaseCommand):
    def handle(self, *args, **options):
        username = os.getenv('DJANGO_SUPERUSER_USERNAME')
        password = os.getenv('DJANGO_SUPERUSER_PASSWORD')
        email = os.getenv('DJANGO_SUPERUSER_EMAIL')

        if not User.objects.filter(username=username).exists():
            User.objects.create_superuser(username=username, password=password, email=email)
            self.stdout.write(self.style.SUCCESS(f'Superuser "{username}" created successfully.'))
        else:
            self.stdout.write(self.style.WARNING(f'Superuser "{username}" already exists.'))

# File: chatbot/chatbot_types/base.py

from abc import ABC, abstractmethod

class BaseChatbot(ABC):
    def __init__(self, chatbot_data):
        self.id = chatbot_data['id']
        self.name = chatbot_data['name']
        self.settings = chatbot_data['settings']

    @abstractmethod
    def generate_response(self, message_content: str, thread_id: str) -> str:
        pass

    @abstractmethod
    def get_settings_schema(self):
        pass

    @abstractmethod
    def validate_settings(self, settings):
        pass

# File: chatbot/chatbot_types/echo/chatbot.py

from ..base import BaseChatbot

class EchoChatbot(BaseChatbot):
    def generate_response(self, message_content: str, thread_id: str) -> str:
        prefix = self.settings.get('echo_prefix', 'Echo: ')
        return f"{prefix}{message_content}"

    def get_settings_schema(self):
        return {
            "echo_prefix": {
                "type": "string",
                "default": "Echo: ",
                "description": "Prefix to add before echoing the message"
            }
        }

    def validate_settings(self, settings):
        if 'echo_prefix' in settings and not isinstance(settings['echo_prefix'], str):
            raise ValueError("echo_prefix must be a string")
        return settings

# File: chatbot/chatbot_types/claudie/chatbot.py

import anthropic
from ..base import BaseChatbot
from typing import List, Dict
import os

class ClaudieChatbot(BaseChatbot):
    def __init__(self, chatbot_data):
        super().__init__(chatbot_data)
        self.client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))
        self.conversation_history: List[Dict[str, str]] = []
        self.character = self.settings.get('character', 'You are a helpful AI assistant.')
        self.documents = self.settings.get('documents', [])

    def generate_response(self, message_content: str, thread_id: str) -> str:
        self.conversation_history.append({"role": "human", "content": message_content})
        
        context = self._retrieve_relevant_context(message_content)
        
        messages = [
            {"role": "system", "content": self.character},
            *self.conversation_history
        ]
        if context:
            messages.append({"role": "system", "content": f"Relevant context: {context}"})

        response = self.client.messages.create(
            model="claude-3.5-sonnet",
            messages=messages
        )

        assistant_message = response.content[0].text
        self.conversation_history.append({"role": "assistant", "content": assistant_message})
        
        return assistant_message

    def get_settings_schema(self):
        return {
            "character": {
                "type": "string",
                "default": "You are a helpful AI assistant.",
                "description": "The character or system prompt for the chatbot"
            },
            "documents": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "path": {"type": "string"}
                    }
                },
                "description": "Uploaded documents for RAG"
            }
        }

    def validate_settings(self, settings):
        if 'character' in settings and not isinstance(settings['character'], str):
            raise ValueError("character must be a string")
        if 'documents' in settings and not isinstance(settings['documents'], list):
            raise ValueError("documents must be a list")
        return settings

    def _retrieve_relevant_context(self, query: str) -> str:
        # Placeholder implementation
        return "Relevant context from documents would be retrieved here."

# File: mochi_bot_backend/asgi.py

"""
ASGI config for mochi_bot_backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mochi_bot_backend.settings')

application = get_asgi_application()


# File: mochi_bot_backend/__init__.py



# File: mochi_bot_backend/settings.py

import os
from dotenv import load_dotenv
from pathlib import Path

load_dotenv()

# Define BASE_DIR
BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv('SECRET_KEY', 'fv^9mvmy#ft6j7z=so2=%9u$w98*#=uqy+1-vtseztykz%u^0!')

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'rest_framework_simplejwt',
    'corsheaders',
    'chatbot',
]

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

SIMPLE_JWT = {
    'AUTH_HEADER_TYPES': ('Bearer',),
}

CORS_ALLOW_CREDENTIALS = True
CORS_ORIGIN_WHITELIST = [
    'http://localhost:3000',
]

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

STATIC_URL = '/static/'
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

ROOT_URLCONF = 'mochi_bot_backend.urls'
WSGI_APPLICATION = 'mochi_bot_backend.wsgi.application'

DEBUG = True

# File: mochi_bot_backend/urls.py

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from chatbot import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/register/', views.register_user),
    path('api/login/', views.login_user),
    path('api/logout/', views.logout_user),
    path('api/chatbot/', views.chatbot_list),
    path('api/chatbot/<str:chatbot_id>/', views.chatbot_detail),
    path('api/thread/', views.create_thread),
    path('api/chatbot/<str:chatbot_id>/<str:thread_id>/chat/', views.send_message),
    path('api/chatbot_types/', views.get_chatbot_types),
    path('api/chatbot/<str:chatbot_id>/upload_document/', views.upload_document),
    path('api/chatbot/<str:chatbot_id>/delete_document/<str:document_name>/', views.delete_document),
    path('api/chatbot/<str:chatbot_id>/documents/', views.get_documents),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

# File: mochi_bot_backend/wsgi.py

"""
WSGI config for mochi_bot_backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mochi_bot_backend.settings')

application = get_wsgi_application()
